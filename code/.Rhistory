xtick<-seq(from=-1,to=2,length.out=1000)
lines(xtick,trueclass(xtick))
x1p <- seq(-1.2,2.2,length.out=200)
x2p <- seq(-1,3,length.out=200)
zp <- as.data.frame(expand.grid(x1p,x2p));names(zp)<-c("x1","x2")
hw2.qdp <- as.numeric(predict(est_class,zp)$class)
contour(x1p,x2p,matrix(hw2.qdp,length(x1p),length(x2p)),levels=c(1.5),add=TRUE, d=FALSE, lty=2)
contour(x1p,x2p,matrix(hw2.ldb,length(x1p),length(x2p)),levels=c(1.5),add=TRUE, d=FALSE, lty=3)
estm1 <- colMeans(sample1)
estm2 <- colMeans(sample2)
estS1 <- cov(sample1)
estS2 <- cov(sample2)
estm1
estm2
estS1
estS2
require(textir);data(congress109);cl <- NULL
#load algorithm
source('hidden_structure.R')
X = congress109Counts
covars <- data.frame(gop=congress109Ideology$party=="R",
cscore=congress109Ideology$cs1)
covars$cscore <- covars$cscore -
tapply(covars$cscore,covars$gop,mean)[covars$gop+1]
rownames(covars) <- rownames(congress109Ideology)
require('plyr');require(textir)
m <- rowSums(X)
m
str(X)
# mnlm does not handle factors! Turn our factor (membership = 1,2 or 3) into vector (membership = [0 1 0]), etc
cl_matrix <- model.matrix(formula(~0+as.factor(clusters)))
make_cl1 <- function(i) {sample(1:i,size=dim(X)[1],replace=TRUE)}
##### random ##########
make_cl1 <- function(i) {sample(1:i,size=dim(X)[1],replace=TRUE)}
make_cl2 <- function(i) {kmeans(X,i)$cluster}
clusters <- make_cl(2)
clusters <- make_cl2(5)
cl_matrix <- model.matrix(formula(~0+as.factor(clusters)))
ncl <- dim(cl_matrix)[2]
ncl
Y<-Y_orig <- as.matrix(cbind(y,cl_matrix))
y <- covars
d.Y <- dim(Y)[2]
)
Y<-Y_orig <- as.matrix(cbind(y,cl_matrix))
head(Y)
d.Y <- dim(Y)[2]
n.meta <- dim(as.matrix(y))[2]
likes <- rep(NA,n.loop) #store likelihood updates here!
fits <- mnlm(cl,Y ,X, bins=5, gamma=1, nlambda=10);
B <- coef(fits)
i = 1
str(X)
str(B)
ll_left <- X%*%t(B[(2+n.meta):d.Y,])   #This ignores the alpha and meta data terms of the coeffecient matrix
head(ll_left)
ll_penal <- cust_sweep(as.matrix(Y[,1:n.meta]) %*% B[2:(1+n.meta),] ,B[1,]) #add intercept and v_i*theta term
cust_sweep <- function(m,v) { sweep(m,MARGIN=2,v,'+')}  #this adds vector v to every row in matrix m
ll_penal <- cust_sweep(as.matrix(Y[,1:n.meta]) %*% B[2:(1+n.meta),] ,B[1,]) #add intercept and v_i*theta term
head(Y[,1:n.meta])
head(ll_penal)
str(ll_penal)
#The apply function is flipping our matrix, etf.
#ll_penal_tot <- vapply(B[3:6,],MARGIN=1,FUN.VALUE=1,FUN=function(x) cust_sweep(ll_penal,x))
#let's try plyr version:
cust_sweep(ll_penal,x)
x
matrix(1:16,nrow=4)
hey <- matrix(1:16,nrow=4)
exp(hey)
exp(5)
exp(4)
exp(4)*e
library(parallel)
hey
parRapply(cl=NULL,x=hey,exp)
parRapplyx=hey,FUN=exp)
parRapply(x=hey,FUN=exp)
cl <- makeCluster(2)
parRapply(cl,x=hey,FUN=exp)
parApply(cl, hey, MARGIN=2, FUN=exp)
parRapply(cl,x=hey,FUN=sum(exp))
parRapply(cl,x=hey,FUN=function(x) sum(exp(x)))
rowSums(exp(hey))
ll_penal_tot <- t(aaply(B[(2+n.meta):d.Y,],.margins=1,.fun=function(x) log(rowSums(exp(cust_sweep(ll_penal,x))))))
str(ll_penal_tot)
head(ll_penal_tot)
head(ll_penal)
dim(ll_penal)
Gamma_cl <-B[(2+n.meta):d.Y,] #the cluster coeffecients
Gamma_cl
help(parRapply)
str(Xhat)
str(Xhat)
Xhat <- cust_sweep(as.matrix(Y[,1:n.meta]) %*% B[2:(1+n.meta),] ,B[1,]) #add intercept and v_i*theta term
ll_penal_tot <- parRapply(cl,x=Gamma_cl,FUN=function(vector) normalize(Xhat,vector))
help(apply)
head(Gamma_cl)
length(Gamma_cl[,1])
length(Gamma_cl[,1])
length(Gamma_cl[,1])
length(Gamma_cl[1,])
mb <- normalize(Xhat,Gamma_cl[1,])
normalize <- function(Xhat,vector) <- log(rowSums(exp(cust_sweep(Xhat,x)))
normalize <- function(Xhat,vector) log(rowSums(exp(cust_sweep(Xhat,x)))
)
mb <- normalize(Xhat,Gamma_cl[1,])
normalize <- function(Xhat,vector) log(rowSums(exp(cust_sweep(Xhat,x)))
)
head(normalize(Xhat,Gamma_cl[1,]))
hey
normalize(hey,1:4)
cust_sweep(hey,1:4)
log(rowSums(exp(cust_sweep(hey,1:4))))
normalize <- function(Xhat,vector) log(rowSums(exp(cust_sweep(Xhat,x))))
normalize(hey,1:4)
cust_sweep(hey,1:4)
log(rowSums(exp(cust_sweep(hey,1:4))))
normalize <- function(Xhat,vector) log(rowSums(exp(cust_sweep(Xhat,x))))
normalize(hey,1:4)
log(rowSums(exp(cust_sweep(hey,1:4))))
ll_penal_tot <- parRapply(cl,x=Gamma_cl,FUN=function(vector) log(rowSums(exp(cust_sweep(Xhat,vector)))))
cust_sweep <- function(m,v) { sweep(m,MARGIN=2,v,'+')}  #this adds vector v to every row in matrix m
ll_penal_tot <- t(aaply(B[(2+n.meta):d.Y,],.margins=1,.fun=function(x) log(rowSums(exp(cust_sweep(ll_penal,x))))))
ll_penal_tot <- parRapply(cl,x=Gamma_cl,FUN=function(vector) log(rowSums(exp(cust_sweep(Xhat,vector)))))
apply(hey,MARGIN=1,FUN=function(x*1:4))
apply(hey,MARGIN=1,FUN=function(x)(x*1:4))
hey
apply(hey,MARGIN=1,FUN=function(x)(x+1))
apply(hey,MARGIN=1,FUN=function(x)(x*(1:4)))
(1:4)*(1:4)
apply(hey,MARGIN=2,FUN=function(x)(x*(1:4)))
apply(hey,MARGIN=2,FUN=function(x)(x+(1:4)))
vec = 1:4
apply(hey,MARGIN=2,FUN=function(x) x+vec)
cl
parRapply(cl,x=hey,MARGIN=2,FUN=function(x) x+vec)
parRapply(cl,x=hey,FUN=function(x) x+vec)
vec
parRapply(cl,x=hey,FUN=function(x) x+vec,vec=vec)
parRapply(cl,x=hey,FUN=function(x) x+vec,vec=1:4)
parRapply(cl,x=hey,FUN=function(x,vec) x+vec,vec=1:4)
vec
parRapply(cl,x=hey,FUN=function(x,vec) x+vec,vec=vec)
parRapply(cl,x=hey,FUN=function(x,vec) sum(x+vec),vec=vec)
gamma_v = Gamma_cl[1,]
length(gamma_v)
parRapply(cl,x=Xhat,FUN=function(m_part,v) log(rowSums(exp(m_part+v))) ,v=gamma_v)
dim(Xhat)
str(Xhat)
parRapply(cl,x=array(Xhat),FUN=function(m_part,v) log(rowSums(exp(m_part+v))) ,v=gamma_v)
dim(cust_sweep(Xhat,gamma_v))
parRapply(cl,x=cust_sweep(Xhat,gamma_v),FUN=function(m_row) log(rowSums(exp(m_row))))
str(cust_sweep(Xhat,gamma_v)
)
str(array(cust_sweep(Xhat,gamma_v))
)
install.packages(c("snow", "snowfall"))
library(snowfall)
sfInit()
sfInit(parallel=TRUE,cpus=2,type="SOCK")
a<-3
sfSapply(1:3, sum, a)
apply(cust_sweep(Xhat,gamma_v),FUN=function(m_row) log(rowSums(exp(m_row))))
apply(cust_sweep(Xhat,gamma_v),MARGIN=1,FUN=function(m_row) log(rowSums(exp(m_row))))
apply(x=cust_sweep(Xhat,gamma_v),MARGIN=1,FUN=function(m_row) log(rowSums(exp(m_row))))
apply(X=cust_sweep(Xhat,gamma_v),MARGIN=1,FUN=function(m_row) log(rowSums(exp(m_row))))
Xhey <- cust_sweep(Xhat,gamma_v)
dim(Xhey)
str(Xhey)
help(apply)
apply(X=Xhey,MARGIN=1,FUN=function(m_row) log(sum(exp(m_row))))
parRapply(cl,x=Xhey,FUN=function(m_row) log(sum(exp(m_row))))
parRapply(cl,x=Xhey,FUN=function(m_row) log(sum(exp(m_row))))
help(parRapply)
require(textir);data(congress109);cl <- NULL
#load algorithm
source('hidden_structure.R')
X = congress109Counts
covars <- data.frame(gop=congress109Ideology$party=="R",
cscore=congress109Ideology$cs1)
covars$cscore <- covars$cscore -
tapply(covars$cscore,covars$gop,mean)[covars$gop+1]
rownames(covars) <- rownames(congress109Ideology)
y <- covars
require('plyr');require(textir)
m <- rowSums(X)
# mnlm does not handle factors! Turn our factor (membership = 1,2 or 3) into vector (membership = [0 1 0]), etc
cl_matrix <- model.matrix(formula(~0+as.factor(clusters)))
make_cl1 <- function(i) {sample(1:i,size=dim(X)[1],replace=TRUE)}
##### random ##########
make_cl1 <- function(i) {sample(1:i,size=dim(X)[1],replace=TRUE)}
clusters <- make_cl2(5)
make_cl2 <- function(i) {kmeans(X,i)$cluster}
clusters <- make_cl2(5)
ncl <- dim(cl_matrix)[2]  #Keep track of how many clusters we're using.
cl_matrix <- model.matrix(formula(~0+as.factor(clusters)))
ncl <- dim(cl_matrix)[2]  #Keep track of how many clusters we're using.
Y<-Y_orig <- as.matrix(cbind(y,cl_matrix))
d.Y <- dim(Y)[2]
n.meta <- dim(as.matrix(y))[2]
likes <- rep(NA,n.loop) #store likelihood updates here!
h.clusters <- array(,dim=c(dim(X)[1],n.loop)) #we'll keep track of cluster assignments over time here
n.loop = 15
h.clusters <- array(,dim=c(dim(X)[1],n.loop)) #we'll keep track of cluster assignments over time here
fits <- mnlm(cl,Y ,X, bins=5, gamma=1, nlambda=10);
B <- coef(fits)
#Initialize a result to return.
res = list(likes,clusters,B,NULL);names(res) <- c("likes","clusters","B","time")
cust_sweep <- function(m,v) { sweep(m,MARGIN=2,v,'+')}  #this adds vector v to every row in matrix m
normalize <- function(Xhat,vector) log(rowSums(exp(cust_sweep(Xhat,x))))
i = 1
ll_left <- X%*%t(B[(2+n.meta):d.Y,])   #This ignores the alpha and meta data terms of the coeffecient matrix
#This is definitely necessary (above)
print("ll_left OK")
#The above formula verified to correctly multiply! We want to maximize ll_left
#  This operation could be simplified by collapsing over metadata levels:        #
Xhat <- cust_sweep(as.matrix(Y[,1:n.meta]) %*% B[2:(1+n.meta),] ,B[1,]) #add intercept and v_i*theta term
Gamma_cl <-B[(2+n.meta):d.Y,] #the cluster coeffecients
hey
hey <- matrix(1:16,nrow=4)
hey
apply(X=cust_sweep(Xhat,gamma_v),MARGIN=1,FUN=function(m_row) log(sum(exp(m_row))))
gamma_v <- Gamma_cl[,1]
apply(X=cust_sweep(Xhat,gamma_v),MARGIN=1,FUN=function(m_row) log(sum(exp(m_row))))
str(apply(X=cust_sweep(Xhat,gamma_v),MARGIN=1,FUN=function(m_row) log(sum(exp(m_row)))))
str(parRapply(cl,x=cust_sweep(Xhat,gamma_v),FUN=function(m_row) log(sum(exp(m_row)))))
cl <- makeCluster(2)
str(parRapply(cl,x=cust_sweep(Xhat,gamma_v),FUN=function(m_row) log(sum(exp(m_row)))))
help(parRapply)
Xhey <- cust_sweep(Xhat,gamma_v)
t
str(parRapply(cl,x=Xhey,FUN=function(m_row) log(sum(exp(m_row)))))
summary((parRapply(cl,x=Xhey,FUN=function(m_row) log(sum(exp(m_row)))))==apply(X=cust_sweep(Xhat,gamma_v),MARGIN=1,FUN=function(m_row) log(sum(exp(m_row)))))
parRapply(cl,x=cust_sweep(Xhat,gamma_v),FUN=function(m_row) log(sum(exp(m_row))))
system.time(apply(X=cust_sweep(Xhat,gamma_v),MARGIN=1,FUN=function(m_row) log(sum(exp(m_row)))))
system.time(parRapply(cl,x=cust_sweep(Xhat,gamma_v),FUN=function(m_row) log(sum(exp(m_row)))))
if(NULL) (echo("hello"))
cl
if(cl) (echo("hello"))
is.null(NULL)
rowSums()
left_term<-function(gamma_v,Xhat) { log(rowSum(exp(cust_sweep(Xhat,gamma_v)))) }
str(Xhat)
parRapply(cl,x = Gamma_cl,FUN=left_term(gamma_v,Xhat),Xhat=Xhat)
left_term<-function(gamma_v,Xhat) { log(rowSums(exp(cust_sweep(Xhat,gamma_v)))) }
parRapply(cl,x = Gamma_cl,FUN=left_term(gamma_v,Xhat),Xhat=Xhat)
left_term(gamma_v,Xhat)
str(left_term(gamma_v,Xhat))
apply(X=Gamma_cl,MARGIN=1,FUN=left_term(gamma_v,matrix),matrix=Xhat)
apply(X=Gamma_cl,MARGIN=1,FUN=left_term(x,matrix),matrix=Xhat)
str(Gamma_cl)
apply(X=Gamma_cl,MARGIN=1,FUN=left_term(x,matrix),matrix=Xhat)
ls()
a
perm
n
lefter_term(gamma_v,Xhat)
left_term(gamma_v,Xhat)
hey
hey+1:4
t(t(hey)+1:4)
hey+t(1:4)
t(1:4)
hey
hey+t(1:4)
dim(Hey)
dim(hey)
system.time(t(t(matrix(1:1e6,nrow=4))+1:4))
system.time(t(t(matrix(1:1e20,nrow=4))+1:4))
system.time(t(t(matrix(1:1e10,nrow=4))+1:4))
1e10
apply(x=matrix(1:1e10,nrow=4),MARGIN=2,FUN=function(x) {x+1:4})
apply(X=matrix(1:1e10,nrow=4),MARGIN=2,FUN=function(x) {x+1:4})
apply(X=matrix(1:1e7,nrow=4),MARGIN=2,FUN=function(x) {x+1:4})
left_term<-function(gamma_v,Xhat) { log(rowSums(exp( t(t(Xhat)+gamma_v) )))) }
left_term<-function(gamma_v,Xhat) { log(rowSums(exp( t(t(Xhat)+gamma_v) )))) }
left_term<-function(gamma_v,Xhat) { log(rowSums(exp( t(t(Xhat)+gamma_v) ))) }
parRapply(cl,x = Gamma_cl,FUN=left_term(x,matrix),matrix=Xhat)
left_term(gamma_v,Xhat)
hey
left_term(hey,1:4)
t(t(hey)+1:4)
t(t(Xhat)+gamma_v) ))
t(t(Xhat)+gamma_v) )
t(t(Xhat)+gamma_v)
dim(Xhat)
dim(gamma_v)
gamma_v
gamma_v = Gamma_cl[1,]
length(gamma_v)
t(t(Xhat)+gamma_v)
dim(t(t(Xhat)+gamma_v) )
left_term(gamma_v,Xhat)
left_term(gamma_v,Xhat)[1,]
left_term(gamma_v,Xhat)[1]
length(Xhat[,1])
log(rowSums(exp(Xhat[1,]+gamma_v)))
log(sum(exp(Xhat[1,]+gamma_v)))
left_term<-function(gamma_v,Xhat) { log(rowSums(exp( t(t(Xhat)+gamma_v) ))) }
str(gamma_v,Xhat)
str(parRapply(cl,x = Gamma_cl,FUN=left_term(x,matrix),matrix=Xhat))
help(apply)
apply(X=Gamma_cl,MARGIN=1,FUN=left_term(x,matrix),matrix=Xhat)
str(left_term(gamma_v,Xhat))
apply(X=Gamma_cl,MARGIN=1,FUN=left_term(x,Xhat))
apply(X=Gamma_cl,MARGIN=1,FUN=function(x)left_term(x,matrix),matrix=Xhat)
apply(X=Gamma_cl,MARGIN=1,FUN=function(x)left_term(x,Xhat))
parRapply(cl,x = Gamma_cl,FUN=function(x)left_term(x,Xhat))
parRapply(cl,x = Gamma_cl,FUN=function(x)left_term(x,Xhat),left_term=left_term)
left_term<-function(x,Xhat) { log(rowSums(exp( t(t(Xhat)+x) ))) }
parRapply(cl,x = Gamma_cl,FUN=function(x)left_term(x,Xhat),left_term=left_term)
parRapply(cl,x = Gamma_cl,FUN=function(x)=log(rowSums(exp( t(t(Xhat)+x) ))))
parRapply(cl,x = Gamma_cl,FUN=function(x) {log(rowSums(exp( t(t(Xhat)+x) )))})
parRapply(cl,x = Gamma_cl,FUN=function(x) {log(rowSums(exp( t(t(Xhat)+x) )))},Xhat=Xhat)
apply(X=Gamma_cl,MARGIN=1,FUN=function(x){log(rowSums(exp( t(t(Xhat)+x) )))},Xhat=Xhat)
help(apply)
apply(X=Gamma_cl,MARGIN=1,FUN=function(x){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat)
apply(X=Gamma_cl,MARGIN=1,FUN=function(x,matrix){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat)
parRapply(cl,x = Gamma_cl,FUN=function(x,matrix) {log(rowSums(exp( t(t(Xhat)+x) )))},matrix=Xhat)
help(parRapply)
parRapply(cl,x = Gamma_cl,FUN=function(x,matrix){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat)
system.time(apply(X=Gamma_cl,MARGIN=1,FUN=function(x,matrix){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat)))
system.time(apply(X=Gamma_cl,MARGIN=1,FUN=function(x,matrix){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat))
system.time(parRapply(cl,x = Gamma_cl,FUN=function(x,matrix){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat))
str(apply(X=Gamma_cl,MARGIN=1,FUN=function(x,matrix){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat) )
m
dim(Xhat)
dim(X)
hey
hey*hey
rowSums(hey*hey)
rowSums
showMethods("rowSums")
dim(Xhat*X)
system.time(Xhat*X)
require(textir);data(congress109);cl <- NULL
#load algorithm
source('hidden_structure.R')
cscore=congress109Ideology$cs1)
rownames(covars) <- rownames(congress109Ideology)
##### random ##########
make_cl1 <- function(i) {sample(1:i,size=dim(X)[1],replace=TRUE)}
##### random ##########
make_cl1 <- function(i) {sample(1:i,size=dim(X)[1],replace=TRUE)}
covars <- data.frame(gop=congress109Ideology$party=="R",
covars$cscore <- covars$cscore -
X = congress109Counts
tapply(covars$cscore,covars$gop,mean)[covars$gop+1]
make_cl1 <- function(i) {sample(1:i,size=dim(X)[1],replace=TRUE)}
covars <- data.frame(gop=congress109Ideology$party=="R",
cscore=congress109Ideology$cs1)
covars$cscore <- covars$cscore -
tapply(covars$cscore,covars$gop,mean)[covars$gop+1]
rownames(covars) <- rownames(congress109Ideology)
res <- iter_cluster(covars,clusters,X,n.loop=5)
source('Iterate.R')
getwd()
setwd("C:/Users/nauner/tech/hidden_structure/code")
source('Iterate.R')
source('Iterate.R')
res <- iter_cluster(covars,clusters,X,n.loop=4)
source('Iterate.R')
system.time(res <- iter_cluster(covars,clusters,X,n.loop=4))
source('Iterate.R')
system.time(res <- iter_cluster(covars,clusters,X,n.loop=4))
Rprof("first_test.out")
first <- iter_cluster(covars,make_cl2(5),X,4)
Rprof(NULL)
source('Iterate.R')
first <- iter_cluster(covars,make_cl2(5),X,4)
str(first)
plot(1:length(cluster_likes),cluster_likes)
with(first,plot(1:length(cluster_likes),cluster_likes))
with(first[1],plot(1:length(cluster_likes),cluster_likes))
first[[1]]
bugzzzzzz
summaryRprof("first_test.out")
ls()
str(totres)
help(save.image)
ls()
naive.dev <- multi.devian(X,as.matrix(covars),coef(fits))
naive.dev
fits <- mnlm(cl, covars,X, bins=5, gamma=1, nlambda=10)
################################################################
# Testing different methods of initializing cluster membership.#
################################################################
#### k -means  #######
require(textir);data(congress109);cl <- NULL
#load algorithm
#source('hidden_structure.R')
source('Iterate.R')
X = congress109Counts
covars <- data.frame(gop=congress109Ideology$party=="R")
#Initialization methods:
##### random ##########
make_cl1 <- function(i) {sample(1:i,size=dim(X)[1],replace=TRUE)}
##### k means on data ##########
make_cl2 <- function(i) {kmeans(X,i)$cluster}
##### k means on residuals#################
fits <- mnlm(cl, covars,X, bins=5, gamma=1, nlambda=10)
resids <- X-m*predict(fits,covars,type="response") #(these are not really good residuals?)
make_cl3 <- function(i) {kmeans(resids,i)$cluster}
# k mean
#test:
fsim.1 <- fsim.2 <- fsim.3<- list()
n_cl = 1
nloop = 20
fsim.1 <- append(fsim.1,list(iter_cluster(covars,make_cl1(n_cl),X,n.loop=nloop)))
help(as.factor)
n_cl <- as.factor(c(1,2,1,2,1,2),levels=c(1,2,3))
n_cl <- factor(c(1,2,1,2,1,2),levels=c(1,2,3))
n_cl
fits
naive.dev <- multi.devian(X,as.matrix(covars),coef(fits))
naive.dev
str(X)
str(covars)
fits <- mnlm(cl, covars,X, bins=5, gamma=1, nlambda=10)
source('Iterate.R')
source('Cluster_congress.R')
require(textir);data(congress109);cl <- NULL
#load algorithm
#source('hidden_structure.R')
source('Iterate.R')
X = congress109Counts
covars <- data.frame(gop=congress109Ideology$party=="R",
cscore=congress109Ideology$cs1)
covars$cscore <- covars$cscore -
tapply(covars$cscore,covars$gop,mean)[covars$gop+1]
rownames(covars) <- rownames(congress109Ideology)
#Initialization methods:
##### random ##########
make_cl1 <- function(i) {sample(1:i,size=dim(X)[1],replace=TRUE)}
##### k means on data ##########
make_cl2 <- function(i) {kmeans(X,i)$cluster}
##### k means on residuals#################
fits <- mnlm(cl, covars,X, bins=5, gamma=1, nlambda=10)
resids <- X-m*predict(fits,covars,type="response") #(these are not really good residuals?)
make_cl3 <- function(i) {kmeans(resids,i)$cluster}
# k mean
n_cl = 5
nloop = 30
  fsim.1 <- append(fsim.1,list(iter_cluster(covars,make_cl1(n_cl),X,n.loop=nloop)))
head(make_cl1(5))
set(make_cl1(5))
unique(make_cl1(5))
n_cl
ll
factor(apply(ll,MARGIN=1,FUN=which.min),levels=1:ncl)
h.clusters[,i] <- n_cl <- factor(apply(ll,MARGIN=1,FUN=which.min),levels=1:ncl) #select cluster to minimize L 
n_cl
n_cl_matrix <- model.matrix(formula(~0+(n_cl))) #and convert to [0 0 1] form. 
Y[,(2+n.meta):d.Y] <- n_cl_matrix
  fsim.1 <- append(fsim.1,list(iter_cluster(covars,make_cl1(n_cl),X,n.loop=nloop)))
dim(n_cl_matrix)

covars
y = covars
clusters<-make_cl1(5)
n_cl
num_cl = 5
nloop = 30
fsim.1 <- append(fsim.1,list(iter_cluster(covars,make_cl1(num_cl),X,n.loop=nloop)))
require('plyr');require(textir)
  m <- rowSums(X)
  # mnlm does not handle factors! Turn our factor (membership = 1,2 or 3) into vector (membership = [0 1 0]), etc
  cl_matrix <- model.matrix(formula(~0+as.factor(clusters)))
  ncl <- dim(cl_matrix)[2]  #Keep track of how many clusters we're using. 
  Y<-Y_orig <- as.matrix(cbind(y,cl_matrix))
  d.Y <- dim(Y)[2]
  n.meta <- dim(as.matrix(y))[2]
  cluster_likes<-full_likes <- rep(NA,n.loop) #store likelihood updates here! 
  h.clusters <- array(,dim=c(dim(X)[1],n.loop)) #we'll keep track of cluster assignments over time here
  fits <- mnlm(cl,Y ,X, bins=5, gamma=1, nlambda=10); 
  B <- coef(fits)
  #Initialize a result to return. 
  likes<-NULL
  res = list(likes,clusters,B,NULL);names(res) <- c("likes","clusters","B","time")
  cust_sweep <- function(m,v) { sweep(m,MARGIN=2,v,'+')}  #this adds vector v to every row in matrix m
  normalize <- function(Xhat,vector) log(rowSums(exp(cust_sweep(Xhat,x))))
  i = 1
 ll_left <- X%*%t(B[(2+n.meta):d.Y,])   #This ignores the alpha and meta data terms of the coeffecient matrix 
    #This is definitely necessary (above)
    print("ll_left OK")
    #The above formula verified to correctly multiply! We want to maximize ll_left
    #  This operation could be simplified by collapsing over metadata levels:        #
    Xhat <- cust_sweep(as.matrix(Y[,1:n.meta]) %*% B[2:(1+n.meta),] ,B[1,]) #add intercept and v_i*theta term
    #The apply function is flipping our matrix, etf. 
    #ll_penal_tot <- vapply(B[3:6,],MARGIN=1,FUN.VALUE=1,FUN=function(x) cust_sweep(ll_penal,x))
    #let's try plyr version:
    Gamma_cl <-B[(2+n.meta):d.Y,] #the cluster coeffecients
    #A quick function to 
    ll_right = m*apply(X=Gamma_cl,MARGIN=1,FUN=function(x,matrix){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat)
    #system.time(apply(X=Gamma_cl,MARGIN=1,FUN=function(x,matrix){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat))
    #system.time(parRapply(cl,x = Gamma_cl,FUN=function(x,matrix){log(rowSums(exp( t(t(matrix)+x) )))},matrix=Xhat))
    print("ll_right OK")
    #Compute total log likelihood
    ll <- ll_right - ll_left  #We cannot expect to be positive as we took out some common terms.   
    cluster_likes[i] <- sum(apply(ll,MARGIN=1,FUN=min))
    full_likes[i] = cluster_likes[i] - rowSums(Xhat*X) #Add in the likelihood from the -x'(alpha+phi*vi)
    #Select new cluster membership if better. 
    h.clusters[,i] <- n_cl <- factor(apply(ll,MARGIN=1,FUN=which.min),levels=1:ncl) #select cluster to minimize L 
    n_cl_matrix <- model.matrix(formula(~0+(n_cl))) #and convert to [0 0 1] form. 
    #update our Y:
    Y[,(2+n.meta):d.Y] <- n_cl_matrix
    #And refit: 
    fits <- mnlm(cl,Y ,X, bins=5, gamma=1, nlambda=10); B <- coef(fits)  #
 
head(n_cl_matrix)
q()
